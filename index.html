<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>お絵描き</title>

<style>
/* ======================================
     Apple風デザイン + ダークモード
   ====================================== */
:root {
    --bg: #f2f2f7;
    --panel: rgba(255,255,255,0.55);
    --panel-border: rgba(180,180,180,0.45);
    --btn-bg: rgba(255,255,255,0.7);
    --btn-border: rgba(0,0,0,0.1);
    --canvas-bg: #ffffff;
    --text: #000;
}

.dark {
    --bg: #1c1c1e;
    --panel: rgba(40,40,40,0.55);
    --panel-border: rgba(80,80,80,0.45);
    --btn-bg: rgba(70,70,70,0.7);
    --btn-border: rgba(255,255,255,0.1);
    --canvas-bg: #2c2c2e;
    --text: #fff;
}

* {
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    background: var(--bg);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    user-select: none;
    color: var(--text);
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    touch-action: none;
}

/* ======================================
     ローディング画面
   ====================================== */
#loadingScreen {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: var(--bg);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    transition: opacity 1.2s ease;
}

.loader {
    width: 55px;
    height: 55px;
    border-radius: 50%;
    border: 6px solid rgba(255,255,255,0.3);
    border-top-color: #007aff;
    animation: spin 1.0s linear infinite;
    box-shadow: 0 0 15px rgba(0,122,255,0.45);
}
@keyframes spin {
    to { transform: rotate(360deg); }
}

/* ======================================
     ツールバー
   ====================================== */
.toolbar {
    position: fixed;
    top: 0;
    width: 100%;
    height: auto;
    min-height: 50px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 6px;
    padding: 8px;
    background: var(--panel);
    backdrop-filter: blur(24px);
    border-bottom: 1px solid var(--panel-border);
    z-index: 10;
}

.icon-btn {
    padding: 8px 12px;
    border-radius: 8px;
    background: var(--btn-bg);
    border: 1px solid var(--btn-border);
    cursor: pointer;
    transition: 0.2s;
    font-size: 13px;
    white-space: nowrap;
    flex-shrink: 0;
}
.icon-btn:active {
    background: rgba(200,200,200,0.9);
    transform: scale(0.95);
}

.icon-btn.active {
    background: #007aff;
    color: white;
}

.color-picker {
    width: 36px;
    height: 36px;
    border-radius: 8px;
    border: 1px solid var(--btn-border);
    cursor: pointer;
    flex-shrink: 0;
}

/* スライダー */
.slider-group {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
}

.slider {
    -webkit-appearance: none;
    width: 80px;
    height: 4px;
    border-radius: 2px;
    background: #c7c7cc;
}
.dark .slider {
    background: #505050;
}
.slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    background: #ffffff;
    border-radius: 50%;
    border: 1px solid #b0b0b0;
}

/* ペン太さプレビュー */
#previewSize {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    flex-shrink: 0;
}

/* ======================================
     キャンバス
   ====================================== */
.canvas-wrapper {
    position: fixed;
    top: 70px;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    overflow: hidden;
}

canvas {
    background: var(--canvas-bg);
    border-radius: 12px;
    box-shadow: 0 8px 28px rgba(0,0,0,0.08);
    max-width: 100%;
    max-height: 100%;
    touch-action: none;
}

/* ======================================
     モバイル用メディアクエリ
   ====================================== */
@media (max-width: 600px) {
    .toolbar {
        gap: 4px;
        padding: 6px;
    }
    
    .icon-btn {
        padding: 6px 10px;
        font-size: 12px;
    }
    
    .slider {
        width: 60px;
    }
    
    .color-picker {
        width: 32px;
        height: 32px;
    }
    
    #previewSize {
        width: 16px;
        height: 16px;
    }
}

@media (max-width: 400px) {
    .icon-btn {
        padding: 5px 8px;
        font-size: 11px;
    }
    
    .slider {
        width: 50px;
    }
}
</style>
</head>

<body>

<!-- ローディング画面 -->
<div id="loadingScreen">
    <div class="loader"></div>
</div>

<!-- ツールバー -->
<div class="toolbar">
    <input type="color" id="color" class="color-picker" value="#000000" />
    <div class="slider-group">
        <input type="range" id="lineWidth" class="slider" min="1" max="30" value="5" />
        <div id="previewSize"></div>
    </div>
    <div class="icon-btn" id="penBtn" onclick="selectPen()">ペン</div>
    <div class="icon-btn" id="eraserBtn" onclick="toggleEraser()">消しゴム</div>
    <div class="icon-btn" id="fillBtn" onclick="toggleFill()">塗りつぶし</div>
    <div class="icon-btn" onclick="undo()">戻る</div>
    <div class="icon-btn" onclick="redo()">進む</div>
    <div class="icon-btn" onclick="clearCanvas()">クリア</div>
    <div class="icon-btn" onclick="downloadCanvas()">保存</div>
    <div class="icon-btn" id="darkModeBtn" onclick="toggleDarkMode()">ダーク</div>
</div>

<!-- キャンバス -->
<div class="canvas-wrapper">
    <canvas id="canvas"></canvas>
</div>

<script>
/* ======================================
      ローディング画面
   ====================================== */
window.addEventListener("load", () => {
    setTimeout(() => {
        const loader = document.getElementById("loadingScreen");
        loader.style.opacity = "0";
        setTimeout(() => { loader.style.display = "none"; }, 1200);
    }, 1800);
});

/* ======================================
      初期設定
   ====================================== */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const colorPicker = document.getElementById("color");
const lineWidthSlider = document.getElementById("lineWidth");
const previewDot = document.getElementById("previewSize");
const darkModeBtn = document.getElementById('darkModeBtn');
const penBtn = document.getElementById('penBtn');
const eraserBtn = document.getElementById('eraserBtn');
const fillBtn = document.getElementById('fillBtn');

let drawing = false;
let isEraser = false;
let isFillMode = false;

let history = [];
let historyIndex = -1;

// キャンバスサイズを画面に合わせる
function resizeCanvas() {
    const wrapper = document.querySelector('.canvas-wrapper');
    const maxWidth = wrapper.clientWidth - 20;
    const maxHeight = wrapper.clientHeight - 20;
    
    // アスペクト比を維持しながらサイズを調整
    const aspectRatio = 3/2;
    let width = Math.min(maxWidth, 900);
    let height = width / aspectRatio;
    
    if (height > maxHeight) {
        height = maxHeight;
        width = height * aspectRatio;
    }
    
    canvas.width = width;
    canvas.height = height;
    
    initBackground();
}

function initBackground() {
    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue("--canvas-bg");
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);
saveState();

/* ======================================
      プレビュー更新
   ====================================== */
function updatePreview() {
    previewDot.style.width = lineWidthSlider.value + "px";
    previewDot.style.height = lineWidthSlider.value + "px";
    previewDot.style.background = isEraser ? "#ffffff" : colorPicker.value;
}

function updateToolButtons() {
    penBtn.classList.toggle('active', !isEraser && !isFillMode);
    eraserBtn.classList.toggle('active', isEraser);
    fillBtn.classList.toggle('active', isFillMode);
}

colorPicker.addEventListener("input", updatePreview);
lineWidthSlider.addEventListener("input", updatePreview);
updatePreview();
updateToolButtons();

/* ======================================
      描画処理 (マウス + タッチ対応)
   ====================================== */
function getPosition(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    return { x, y };
}

function startDrawing(e) {
    e.preventDefault();
    drawing = true;
    const pos = getPosition(e);
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);

    if (isFillMode) {
        floodFill(Math.floor(pos.x), Math.floor(pos.y), hexToRgb(colorPicker.value));
        saveState();
        drawing = false;
    }
}

function stopDrawing(e) {
    if (e) e.preventDefault();
    if (drawing && !isFillMode) saveState();
    drawing = false;
}

function draw(e) {
    if (!drawing || isFillMode) return;
    e.preventDefault();
    
    const pos = getPosition(e);
    ctx.lineWidth = lineWidthSlider.value;
    ctx.lineCap = "round";
    ctx.strokeStyle = isEraser ? getComputedStyle(document.body).getPropertyValue("--canvas-bg") : colorPicker.value;
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
}

// マウスイベント
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mouseup", stopDrawing);
canvas.addEventListener("mousemove", draw);
canvas.addEventListener("mouseleave", stopDrawing);

// タッチイベント
canvas.addEventListener("touchstart", startDrawing, { passive: false });
canvas.addEventListener("touchend", stopDrawing, { passive: false });
canvas.addEventListener("touchmove", draw, { passive: false });
canvas.addEventListener("touchcancel", stopDrawing, { passive: false });

/* ======================================
      履歴管理
   ====================================== */
function saveState() {
    history = history.slice(0, historyIndex + 1);
    history.push(ctx.getImageData(0,0,canvas.width,canvas.height));
    historyIndex++;
}
function undo() { 
    if(historyIndex>0) {
        ctx.putImageData(history[--historyIndex],0,0);
    }
}
function redo() { 
    if(historyIndex<history.length-1) {
        ctx.putImageData(history[++historyIndex],0,0);
    }
}

/* ======================================
      ツール
   ====================================== */
function toggleEraser() { 
    isEraser = !isEraser; 
    isFillMode = false;
    updatePreview();
    updateToolButtons();
}

function selectPen() { 
    isEraser = false; 
    isFillMode = false; 
    updatePreview();
    updateToolButtons();
}

function toggleFill() { 
    isFillMode = !isFillMode; 
    if(isFillMode) isEraser = false;
    updateToolButtons();
}

function clearCanvas() { 
    initBackground(); 
    saveState(); 
}

function downloadCanvas() {
    const link = document.createElement("a");
    link.download = "HARUOMILABO.png";
    link.href = canvas.toDataURL();
    link.click();
}

/* ======================================
      ダークモード切替 + 保存
   ====================================== */
window.addEventListener('load', () => {
    const darkStored = localStorage.getItem('darkMode') === 'true';
    if(darkStored) document.body.classList.add('dark');
    updateDarkModeBtn();
});

function toggleDarkMode() {
    document.body.classList.toggle('dark');
    const currentImage = ctx.getImageData(0,0,canvas.width,canvas.height);
    initBackground();
    ctx.putImageData(currentImage, 0, 0);
    saveState();
    const isDark = document.body.classList.contains('dark');
    localStorage.setItem('darkMode', isDark);
    updateDarkModeBtn();
}

function updateDarkModeBtn() {
    darkModeBtn.textContent = document.body.classList.contains('dark') ? 'ライト' : 'ダーク';
}

/* ======================================
      塗りつぶし処理
   ====================================== */
function hexToRgb(hex) {
    return [
        parseInt(hex.substr(1,2),16),
        parseInt(hex.substr(3,2),16),
        parseInt(hex.substr(5,2),16),
        255
    ];
}

function floodFill(x, y, fillColor) {
    const img = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;
    const startColor = getPixel(data,x,y);
    if(matchColor(startColor,fillColor)) return;
    const stack = [[x,y]];
    while(stack.length){
        const [cx,cy]=stack.pop();
        if(cx<0||cy<0||cx>=canvas.width||cy>=canvas.height) continue;
        const current = getPixel(data,cx,cy);
        if(!matchColor(current,startColor)) continue;
        setPixel(data,cx,cy,fillColor);
        stack.push([cx+1,cy]);
        stack.push([cx-1,cy]);
        stack.push([cx,cy+1]);
        stack.push([cx,cy-1]);
    }
    ctx.putImageData(img,0,0);
}

function getPixel(data,x,y){
    const i=(y*canvas.width+x)*4;
    return [data[i],data[i+1],data[i+2],data[i+3]];
}

function setPixel(data,x,y,color){
    const i=(y*canvas.width+x)*4;
    data[i]=color[0]; data[i+1]=color[1]; data[i+2]=color[2]; data[i+3]=color[3];
}

function matchColor(a,b){
    return a[0]===b[0] && a[1]===b[1] && a[2]===b[2] && a[3]===b[3];
}
</script>

</body>
</html>
